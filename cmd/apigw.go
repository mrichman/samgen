package cmd

import (
	"os"
	"path/filepath"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/awslabs/goformation/v5/cloudformation"
	"github.com/getkin/kin-openapi/openapi3"
	apigw "github.com/mrichman/samgen/apigateway"
	"github.com/mrichman/samgen/util"
	"github.com/spf13/cobra"
)

// apigwCmd represents the import command
var apigwCmd = &cobra.Command{
	Use:   "apigw",
	Short: "Import an existing API Gateway REST API",
	Long:  "Import an existing API Gateway REST API",
	Run: func(cmd *cobra.Command, args []string) {

		apiId, _ := cmd.Flags().GetString("rest-api-id")
		stage, _ := cmd.Flags().GetString("stage")
		projectName, _ := cmd.Flags().GetString("project-name")
		verbose, _ := cmd.Flags().GetBool("verbose")

		if verbose {
			log.SetLevel(log.DebugLevel)
			log.Debug("Verbose logs enabled")
		}

		export, _ := apigw.ExportRestApi(apiId, stage)

		loader := openapi3.NewLoader()
		doc, err := loader.LoadFromData(export)
		if err != nil {
			log.Fatalf("Could not load Open API spec: %v", err)
		}
		err = doc.Validate(loader.Context)
		if err != nil {
			log.Fatalf("Could not validate Open API spec: %v", err)
		}

		// Create project directory
		_, err = os.Stat(projectName)

		if os.IsNotExist(err) {
			errDir := os.MkdirAll(projectName, 0755)
			if errDir != nil {
				log.Fatal(err)
			}

		}

		// Create a new CloudFormation template
		template := cloudformation.NewTemplate()
		transform := "AWS::Serverless-2016-10-31"
		template.Description = "Template generated by samgen [https://github.com/mrichman/samgen]"
		template.Transform = &cloudformation.Transform{String: &transform}

		for _, pathItem := range doc.Paths {
			for verb, operation := range pathItem.Operations() {
				log.Debugf("Generating resource for: %s /%s", verb, operation.OperationID)
				function, _ := util.GenerateServerlessFunction(verb, operation)
				functionName := strings.Title(operation.OperationID) + "Function"
				template.Resources[functionName] = function

				// Generate skeleton function in ./functions directory
				newpath := filepath.Join(".", projectName, "functions", operation.OperationID)
				util.WriteFunction(newpath)
			}
		}

		// Output the YAML AWS CloudFormation template
		y, err := template.YAML()
		if err != nil {
			log.Fatalf("Failed to generate YAML: %s", err)
		} else {
			log.Tracef("%s", string(y))
			outfile := filepath.Join(projectName, "template.yaml")
			f, err := os.Create(outfile)
			if err != nil {
				log.Fatalf("Could not create file %s: %v", outfile, err)
			}
			_, err = f.Write(y)
			if err != nil {
				log.Fatalf("Could not write file %s: %v", outfile, err)
				f.Close()
				return
			}
		}
	},
}

func init() {
	apigwCmd.Flags().String("rest-api-id", "", "The string identifier of the associated RestApi (e.g. a1b2c3d4e5)")
	apigwCmd.Flags().String("stage", "", "The name of the Stage that will be exported (e.g. prod)")
	apigwCmd.Flags().String("project-name", "", "The directory to save the project as")
	apigwCmd.PersistentFlags().Bool("verbose", false, "Verbose logging")
	apigwCmd.MarkFlagRequired("rest-api-id")
	apigwCmd.MarkFlagRequired("stage")
	apigwCmd.MarkFlagRequired("project-name")
	rootCmd.AddCommand(apigwCmd)
}
